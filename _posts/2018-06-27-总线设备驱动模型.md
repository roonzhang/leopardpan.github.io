---
layout: post
title: "总线、设备、驱动模型"
date: 2018-06-28
description: "设备驱动模型"
tag: 设备驱动
---   
------

最近一直从事**VxWorks**的驱动开发，操作系统的设备驱动模型比较简单，与硬件相关的操作统一挂在**IO系统**下，在实际的应用中，调用统一的IO接口，例如`open、ioctl、read、write、select`等，即可完成对硬件的操作，以此实现驱动与应用程序的低耦合（主要指的字符设备驱动）。结合**Linux**设备驱动模型在此做一个总结。

操作硬件最关键的便是`基地址和中断号`了，而世界上的板子千千万，每个板子的信息也不一样，站在驱动开发的角度来看，每次重新更换板卡时，基地址和中断号不一样，则驱动程序也需要更改为相对应的参数，如此一来，千千万的板卡就需要千千万的驱动程序，而驱动程序就是想要以不变应万变，这个时候，设备驱动模型就显得尤其重要了。

-----
### 设备驱动模型
-----

按照我们上面的分析，驱动程序想要实现不变应万变，那么CPU板级信息应与驱动程序分离，这是我们设计的前提。但是驱动是一定要去取基地址和中断号的，而基地址和中断号与与硬件又是密切相关的，中间这层耦合关系似乎很难隔离。

最简单的办法，**轮询匹配**，驱动程序满世界询问各个板卡，你的基地址是多少，中断号是多少，或者通过设定的几个预设值去匹配。其实，你可以发现，这还是一个耦合的情况。

在VxWorks7.0以前都是通过这种类似的形式去匹配的，比如pci设备的查询接口`pciFindDevice`，pci是有查询配置空间的这样一个机制，而其他板卡呢？比如与pci对应的`isa`，还有其他板级总线，`i2c、spi`呢？他们与基地址和中断号的联系更紧密，而且在不知道基地址的情形下他们无法给你回应，这个时候一般在创建设备的接口中预留参数作为输入。

我们也可以换一个思路，设计一个接口适配器（adapter）的类去适配不同的板级信息，基地址、中断号全部全部放到`adpter`里去维护，而驱动则通过`adpter`的接口去获取相对应的硬件信息。**Linux**采用的便是这种方法，只不过不叫`adpter`，叫做总线。

这是一篇测试博客，**Linux** 下驱动模型：

> * 设备
> * 总线
> * 驱动

------

## 二标题

Markdown **粗体** 或者 *斜体* 某些文字 `测试` `test`

### 1. 制作一份待办事宜

- [ ] 支持以 PDF 格式导出文稿
- [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率
- [x] 新增 Todo 列表功能
- [x] 修复 LaTex 公式渲染问题
- [x] 新增 LaTex 公式编号功能

### 3. 高亮一段代码[^code]

```c
int sbs_ad_maxch_get(void)
{
	int i = 0, ret = 0;

	if (g_board_index == 0) {
		return -1;
	}

	for (i = 0; i < g_board_index; i++) {
		ret += gs_board_info[i].ch_ad;
	}

	return ret;
}
```

### 7. 绘制表格

| 项目        | 价格   |  数量  |
| --------   | :-----:  | :----:  |
| 计算机      | \$1600 |   5     |
| 手机        |   \$12   |   12   |
| 管线        |    \$1    |  234  |


------

作者 [迷死她张]
2018 年 06月 27日
